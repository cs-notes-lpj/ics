### 介绍几个程序工具

程序工具 `xxd` 用于将二进制文件以十六进制形式进行输出

```bash
tldr xxd
Create a hexadecimal representation (hexdump) from a binary file, or vice-versa.
...
```

程序工具 `file` 可用于查看文件类型

```bash
tldr file
Determine file type.
...
```

程序工具 `objdump` 可用于反汇编二进制文件

```bash
tldr objdump
View information about object files.
...
```

### 介绍一些背景知识

[源代码的编译过程](https://cs-notes-lpj.github.io/dev-c-on-linux/#/docs/1)

ELF: Executable and Linkable Format

以下代码有啥区别 ？

```c
#include <stdio.h>
#include "stdio.h"
```

干瞪眼儿看当然看不出来有啥实质性区别，我们不妨对代码进行编译操作

从编译日志中就能发现这两行代码的区别

注：verbose，详细的，即输出详细的编译日志

![20230118103414](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-clipboard/20230118103414.png)

---

[这里](https://cs-notes-lpj.github.io/dev-c-on-linux/#/docs/2)是一些值得复习的关于 gcc 的编译选项的知识

但其中关于「引用库时发生错误」的相关解释不太好，这里给出更好的解释

```
# 若引用库时发生错误
# xxx.h: no such file or directory

# 1. 有可能你的电脑中确实没有安装该库
# 2. 也有可能你确实安装了该库，但 gcc 在编译时并未从此次编译的搜索路径中检索到该库
   # 这种情况下，若想要编译通过，你可以使用`ln`或`mv`，让 gcc 能在默认的库检索路径中搜到该库
   # 当然你也可以在编译时使用`-I`编译选项，将库的真实路径添加到编译时的库搜索路径集中
    gcc demo.c -I/my/include/path
```

### 心得

.c 文件经过预编译(-E)之后看得更清

比如

```c
#if aa == bb
    printf("Yes\n");
#else
    printf("No\n");
#endif
```

经过预编译之后，就只剩一行`printf("Yes\n");`了

另外，不难看到 C 语言中具备分支能力的不仅有常规的`if{...}else{...}`，预编译中的代码也有分支能力，能起到缩减代码量的效果

另外，我们能够使用`#ifdef`来检测是否有某些「宏」被定义，进而决定是否执行特定代码段，如下代码(foo.c)为例

```c
#ifdef __x86_64__
    printf("64");
#else
    printf("32");
#endif
```

执行`gcc foo.c`，运行生成产物会输出 64

执行`gcc foo.c -m32`，运行生成产物会输出 32

### 预编译的本质：复制粘贴

![20230118101121](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-clipboard/20230118101121.png)

代码优化：剔除“复制粘贴”进来的无用代码

![20230118114411](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-clipboard/20230118114411.png)



